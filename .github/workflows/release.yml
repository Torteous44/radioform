name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 1.0.0)"
        required: true

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

env:
  MACOSX_DEPLOYMENT_TARGET: "13.0"

jobs:
  build-and-release:
    name: Build, Sign, Notarize & Release
    runs-on: macos-14
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Fetch libASPL tags
        run: |
          git -C packages/driver/vendor/libASPL fetch --tags --force --prune --update-shallow || true

      - name: Determine version
        id: version
        run: |
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/v}"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Building version: $VERSION"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Update Component Versions
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Update Component Versions
        run: |
          # Check if driver code has changed since last release
          CURRENT_DRIVER_VERSION=$(cat packages/driver/VERSION 2>/dev/null || echo "1.0.0")
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")

          # Check if driver files changed since last tag
          DRIVER_CHANGED=$(git diff --name-only "$LAST_TAG" HEAD -- packages/driver/src packages/driver/include packages/driver/CMakeLists.txt 2>/dev/null | wc -l || echo "1")

          if [ "$DRIVER_CHANGED" -gt 0 ]; then
            echo "ğŸ”§ Driver code changed - updating all components to ${{ steps.version.outputs.version }}"
            ./tools/update_versions.sh ${{ steps.version.outputs.version }}
          else
            echo "ğŸ“± Driver unchanged - updating app only to ${{ steps.version.outputs.version }}"
            ./tools/update_versions.sh ${{ steps.version.outputs.version }} --app-only
            echo "   Driver remains at version: $CURRENT_DRIVER_VERSION"
          fi

          echo "âœ“ Version update complete"

          # Show what changed for verification
          git diff apps/mac/RadioformApp/Info.plist packages/driver/Info.plist packages/host/Info.plist

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Install Apple Certificate
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Install Apple Certificate
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate from base64
          echo -n "$APPLE_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify certificate installed
          security find-identity -v -p codesigning $KEYCHAIN_PATH

          echo "âœ“ Apple certificate installed"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Build All Components
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Build DSP Library (universal)
        run: |
          cmake -S packages/dsp -B packages/dsp/build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build packages/dsp/build --config Release --parallel
          echo "âœ“ DSP library built (universal)"

      - name: Build HAL Driver (universal)
        run: |
          cmake -S packages/driver -B packages/driver/build \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build packages/driver/build --config Release --parallel
          echo "âœ“ HAL driver built (universal)"

      - name: Build Host Engine (universal)
        run: |
          swift build --configuration release --package-path packages/host \
            --triple arm64-apple-macosx
          swift build --configuration release --package-path packages/host \
            --triple x86_64-apple-macosx
          mkdir -p packages/host/.build/universal/release
          lipo -create -output packages/host/.build/universal/release/RadioformHost \
            packages/host/.build/arm64-apple-macosx/release/RadioformHost \
            packages/host/.build/x86_64-apple-macosx/release/RadioformHost
          echo "âœ“ Host engine built (universal)"

      - name: Build Menu Bar App (universal)
        run: |
          swift build --configuration release --package-path apps/mac/RadioformApp \
            --triple arm64-apple-macosx
          swift build --configuration release --package-path apps/mac/RadioformApp \
            --triple x86_64-apple-macosx
          mkdir -p apps/mac/RadioformApp/.build/universal/release
          lipo -create -output apps/mac/RadioformApp/.build/universal/release/RadioformApp \
            apps/mac/RadioformApp/.build/arm64-apple-macosx/release/RadioformApp \
            apps/mac/RadioformApp/.build/x86_64-apple-macosx/release/RadioformApp
          echo "âœ“ Menu bar app built (universal)"

      - name: Verify universal architectures
        run: |
          echo "Verifying universal binary architectures..."
          lipo -archs packages/dsp/build/libradioform_dsp.a
          lipo -archs packages/driver/build/RadioformDriver.driver/Contents/MacOS/RadioformDriver
          lipo -archs packages/host/.build/universal/release/RadioformHost
          lipo -archs apps/mac/RadioformApp/.build/universal/release/RadioformApp
          echo "âœ“ All binaries are universal"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Create App Bundle
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Create App Bundle
        run: |
          make bundle
          echo "âœ“ App bundle created"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Code Sign
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Code Sign App
        run: |
          make sign
          echo "âœ“ App signed"

      - name: Verify Signatures
        run: |
          ./tools/verify_signatures.sh
          echo "âœ“ Signatures verified"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Notarize
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Notarize App
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create zip for notarization
          ditto -c -k --keepParent dist/Radioform.app dist/Radioform.zip

          RESULT_JSON=$(mktemp)

          # Submit for notarization and capture the result
          if ! xcrun notarytool submit dist/Radioform.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --output-format json > "$RESULT_JSON"; then
            echo "Notary submission failed"
            cat "$RESULT_JSON" || true
            SUBMISSION_ID=$(python -c 'import json,sys, pathlib; p=pathlib.Path(sys.argv[1]); data=json.loads(p.read_text()) if p.exists() else {}; print(data.get("id",""))' "$RESULT_JSON")
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_ID_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi
            exit 1
          fi

          STATUS=$(python -c 'import json,sys, pathlib; p=pathlib.Path(sys.argv[1]); data=json.loads(p.read_text()) if p.exists() else {}; print(data.get("status",""))' "$RESULT_JSON")
          SUBMISSION_ID=$(python -c 'import json,sys, pathlib; p=pathlib.Path(sys.argv[1]); data=json.loads(p.read_text()) if p.exists() else {}; print(data.get("id",""))' "$RESULT_JSON")

          echo "Submission ID: ${SUBMISSION_ID}"
          echo "Status: ${STATUS}"

          if [ "$STATUS" != "Accepted" ]; then
            echo "Notary submission returned status: $STATUS"
            if [ -n "$SUBMISSION_ID" ]; then
              xcrun notarytool log "$SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_ID_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
            fi
            exit 1
          fi

          # Staple the ticket
          xcrun stapler staple dist/Radioform.app

          # Clean up
          rm dist/Radioform.zip "$RESULT_JSON"

          echo "âœ“ App notarized and stapled"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Create DMG
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Install DMG Tools
        run: |
          brew install create-dmg
          echo "âœ“ create-dmg installed"

      - name: Create DMG
        run: |
          DMG_NAME="Radioform.dmg"

          # Use the create_dmg.sh script for proper layout (app + Applications symlink)
          ./tools/create_dmg.sh

          # Sign the DMG
          IDENTITY=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F'"' '{print $2}')
          codesign --force --sign "$IDENTITY" "dist/${DMG_NAME}"

          # Notarize the DMG
          xcrun notarytool submit "dist/${DMG_NAME}" \
            --apple-id "${{ secrets.APPLE_ID }}" \
            --password "${{ secrets.APPLE_ID_PASSWORD }}" \
            --team-id "${{ secrets.APPLE_TEAM_ID }}" \
            --wait

          xcrun stapler staple "dist/${DMG_NAME}"

          echo "dmg_name=${DMG_NAME}" >> "$GITHUB_OUTPUT"
          echo "âœ“ DMG created: ${DMG_NAME}"
        id: dmg

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Install Sparkle Tools
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Install Sparkle Tools
        run: |
          brew install sparkle
          # Add Sparkle CLI tools to PATH (generate_appcast lives inside the cask payload)
          SPARKLE_BIN=$(find "$(brew --prefix)/Caskroom/sparkle" -name generate_appcast -type f | head -1)
          if [ -z "$SPARKLE_BIN" ]; then
            SPARKLE_BIN=$(find /Applications -path "*Sparkle*bin/generate_appcast" -type f | head -1)
          fi
          if [ -z "$SPARKLE_BIN" ]; then
            echo "âŒ generate_appcast not found after installing Sparkle cask"
            exit 1
          fi
          echo "Found generate_appcast at $SPARKLE_BIN"
          echo "SPARKLE_BIN=$SPARKLE_BIN" >> $GITHUB_ENV

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Generate Sparkle Appcast
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Generate Sparkle Appcast
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
          APP_VERSION: ${{ steps.version.outputs.version }}
          DMG_NAME: ${{ steps.dmg.outputs.dmg_name }}
        run: |
          if [ -z "$SPARKLE_PRIVATE_KEY" ]; then
            echo "âŒ SPARKLE_PRIVATE_KEY secret is not set"
            exit 1
          fi

          KEY_PATH="$RUNNER_TEMP/sparkle_ed25519.key"
          # Secret should be the raw Ed25519 private key string (as generated by Sparkle's generate_keys)
          printf "%s" "$SPARKLE_PRIVATE_KEY" > "$KEY_PATH"

          DOWNLOAD_PREFIX="https://github.com/${{ github.repository }}/releases/download/v${APP_VERSION}"

          # Generate appcast with signature
          "${SPARKLE_BIN}" \
            --ed-key-file "$KEY_PATH" \
            --download-url-prefix "$DOWNLOAD_PREFIX/" \
            dist

          if [ -f dist/appcast.xml ]; then
            echo "âœ“ Appcast generated at dist/appcast.xml"
          else
            echo "âŒ generate_appcast did not produce dist/appcast.xml"
            ls dist
            exit 1
          fi

          head -n 10 dist/appcast.xml

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Generate Checksums
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Generate Checksums
        run: |
          cd dist
          shasum -a 256 *.dmg > checksums.txt
          cat checksums.txt
          echo "âœ“ Checksums generated"

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Generate Release Notes
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Install git-cliff
        run: |
          brew install git-cliff

      - name: Get previous tag
        id: previoustag
        run: |
          PREV_TAG=$(git tag --sort=-version:refname | grep -v "${GITHUB_REF#refs/tags/}" | head -n1)
          echo "tag=${PREV_TAG:-$(git rev-list --max-parents=0 HEAD)}" >> $GITHUB_OUTPUT

      - name: Generate release notes
        run: |
          CURRENT_TAG=${GITHUB_REF#refs/tags/}
          PREV_TAG=${{ steps.previoustag.outputs.tag }}

          git cliff --config .github/cliff.toml --strip header --current ${PREV_TAG}..${CURRENT_TAG} > release_notes.md

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Create GitHub Release
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          name: Radioform v${{ steps.version.outputs.version }}
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, 'beta') || contains(steps.version.outputs.version, 'alpha') }}
          body_path: release_notes.md
          files: |
            dist/*.dmg
            dist/appcast.xml
            dist/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      #  Cleanup
      # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
      - name: Cleanup Keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
